import networkx as nx
import matplotlib.pyplot as plt

# generated by claude
class DependencyGraph:
    def __init__(self):
        # Store dependencies as adjacency lists
        self.dependencies = {}
        # Store reverse dependencies for efficient lookup
        self.reverse_deps = {}
        
    def add_node(self, node):
        """Add a node to the graph if it doesn't exist."""
        if node not in self.dependencies:
            self.dependencies[node] = set()
            self.reverse_deps[node] = set()
    
    def add_dependency(self, dependent, dependency):
        """Add a dependency: dependent depends on dependency."""
        # Add both nodes if they don't exist
        self.add_node(dependent)
        self.add_node(dependency)
        
        # Add the dependency relationship
        self.dependencies[dependent].add(dependency)
        self.reverse_deps[dependency].add(dependent)
        
        # Check for cycles
        if self._has_cycle():
            # Remove the added dependency
            self.dependencies[dependent].remove(dependency)
            self.reverse_deps[dependency].remove(dependent)
            raise ValueError(f"Adding {dependent} -> {dependency} would create a cycle")
    
    def _has_cycle(self):
        """Check if the graph has any cycles using DFS."""
        visited = set()
        path = set()
        
        def dfs(node):
            visited.add(node)
            path.add(node)
            
            for neighbor in self.dependencies[node]:
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in path:
                    return True
                    
            path.remove(node)
            return False
        
        for node in self.dependencies:
            if node not in visited:
                if dfs(node):
                    return True
        return False
    
    def get_all_dependencies(self, node):
        """Get all dependencies of a node (direct and indirect)."""
        if node not in self.dependencies:
            raise ValueError(f"Node {node} not in graph")
            
        all_deps = set()
        def collect_deps(n):
            for dep in self.dependencies[n]:
                if dep not in all_deps:
                    all_deps.add(dep)
                    collect_deps(dep)
                    
        collect_deps(node)
        return all_deps

    def get_direct_dependencies(self, node):
        return self.dependencies[node]
    
    def get_dependents(self, node):
        """Get all nodes that depend on this node."""
        if node not in self.reverse_deps:
            raise ValueError(f"Node {node} not in graph")
        return self.reverse_deps[node]
    
    def get_build_order(self):
        """Return a valid build order (topological sort)."""
        result = []
        visited = set()

        def dfs(node):
            if node in visited:
                return 
            visited.add(node)
            
            for dep in self.dependencies[node]:
                dfs(dep)
            result.append(node)

        # Visit all nodes
        for node in self.dependencies:
            dfs(node)

        return result  # No need to reverse since order is correct
    
    def get_all_build_orders(self):
        """Return all possible build orders (topological sorts)."""
        result = []
        build_order = []
        in_progress = set()  # Tracks nodes currently being added
        dependencies = {node: set(deps) for node, deps in self.dependencies.items()}  # Copy dependencies

        def dfs():
            if len(build_order) == len(self.dependencies):
                result.append(build_order[:])  # Add a copy of the current build order
                return
            
            for node in self.dependencies:
                if node not in in_progress and dependencies[node] <= set(build_order):
                    # Try adding this node to the current build order
                    build_order.append(node)
                    in_progress.add(node)
                    dfs()
                    # Backtrack
                    build_order.pop()
                    in_progress.remove(node)
        
        dfs()
        return result
    
    def get_root_nodes(self):
        """Get nodes that don't depend on anything."""
        return {node for node in self.dependencies 
                if not self.dependencies[node]}
    
    def get_leaf_nodes(self):
        """Get nodes that nothing depends on."""
        return {node for node in self.dependencies 
                if not self.reverse_deps[node]}
    
    def __str__(self):
        """String representation showing all dependencies."""
        return '\n'.join(f"{node} -> {deps}" 
                        for node, deps in self.dependencies.items()
                        if deps)

    def visualize(self):
        G = nx.DiGraph()
        for src, targets in self.dependencies.items():
            for tgt in targets:
                G.add_edge(src, tgt)
                
        # Compute the topological ordering to determine x-positions
        try:
            layers = list(nx.topological_generations(G))
        except nx.NetworkXUnfeasible:
            print("Graph contains cycles, cannot determine proper ordering")
            return
            
        # Create positions dictionary
        pos = {}
        
        # Group nodes by robot (extract robot ID from node name)
        robot_groups = {}
        for node in G.nodes():
            if node == "terminal":
                continue
            robot_id = node.split('_')[0]  # Assumes format "aX_rY_..."
            if robot_id not in robot_groups:
                robot_groups[robot_id] = []
            robot_groups[robot_id].append(node)
        
        # Calculate number of robot groups for scaling
        num_robots = len(robot_groups)
        
        # Assign vertical positions by robot group
        max_x = -1e6
        vertical_spacing = 1.0 / (num_robots + 1)
        for i, (robot_id, nodes) in enumerate(sorted(robot_groups.items())):
            y_pos = (i + 1) * vertical_spacing
            for node in nodes:
                # Find which layer this node is in
                for layer_idx, layer in enumerate(layers):
                    if node in layer:
                        pos[node] = (-layer_idx, y_pos)
                        max_x = max(pos[node][0], max_x)
                        break
        
        # Position terminal node at the right, vertically centered
        pos["terminal"] = (max_x + 1, 0.5)
        num_nodes = len(G.nodes())
        box_width = max(0.6, min(0.4, 2.0 / num_nodes))
        box_height = max(0.05, min(0.1, 0.5 / num_nodes))
        font_size = max(6, min(8, 400 / num_nodes))
        
        plt.figure(figsize=(12, 8))
        
        nx.draw_networkx_edges(G, pos, 
                          edge_color="gray",
                          arrows=True,
                          arrowsize=20,
                          width=1.5,
                          arrowstyle='-|>',  # Changed arrow style
                          connectionstyle='arc3,rad=0.3')  # Increased arc
    
                
        # Draw rectangular nodes
        for node, (x, y) in pos.items():
            rect = plt.Rectangle((x - box_width/2, y - box_height/2), 
                            box_width, box_height, 
                            facecolor='lightblue', 
                            edgecolor='black')
            plt.gca().add_patch(rect)
            plt.text(x, y, node, 
                    horizontalalignment='center',
                    verticalalignment='center',
                    fontsize=font_size,
                    fontweight='bold')
        
        # Set plot limits with some padding
        plt.ylim(-0.1, 1.1)
        
        plt.title("Task Dependency Graph by Robot")
        plt.axis('equal')
        plt.show()